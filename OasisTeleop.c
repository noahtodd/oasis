#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     FL,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     BL,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     BR,            tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

float initial; float rotation; float radRotation; int lastTime = 0;//initial is the initial Gyro readings. Rotation is the robot's yaw
float FLset; float FRset; //stand for front right set and front left set, which refer to the wheels on the robot
float joyAngle; //joystick angle

void moveDirection(float angle, float magnitude){
	FLset = magnitude * (cos(angle) + sin(angle));
	FRset = magnitude * (sin(angle) - cos(angle));
}

void initializeRobot(){
	// Finds average still gyro reading
	for(int i = 0; i < 100; i++){
		initial += SensorValue[S4];
		wait10Msec(1);
	}
	initial = initial / 100;
  return;
}

task superDrive(){
	float x1,y1,x2,y2,LF,RF,LB,RB= 0;
	int minJoy = 12;
	float turning;
	float mag; //magnitude of the joystick vector
	float initialHeading = radRotation; float calcHeading = radRotation;
	float movementAmount, turningAmount, totalAmount;
	while(true){
		// Get joystick values
		x1 = joystick.joy1_x1 * .5;y1 = joystick.joy1_y1 * .5;
		x2 = joystick.joy1_x2 * .5;y2 = joystick.joy1_y2 * .5;
		// function for making new initial heading
		if (joy1Btn(5)==1){
			initialHeading = radRotation;
		}
		if (joy1Btn(6)==1){
			// find joystick vector angle
			joyAngle = atan2(y1, x1);
			// find joystick vector magnitude
			mag = sqrt(x1*x1+y1*y1)/2;
			if (mag>64)
				mag = 64;
			// get calculated heading
			calcHeading = radRotation - initialHeading;
			// find the direction needed to move
	    moveDirection(joyAngle + calcHeading, mag);
	    // fix movement drifting
	    if (abs(joystick.joy1_x1)<minJoy&&abs(joystick.joy1_y1)<minJoy/*&&abs(joystick.joy1_x2)<minJoy*/){
				FLset=0;FRset=0;
			}
			// find turning magnitude
			turning = x2/2;
			//fix turning drifting
			if (abs(joystick.joy1_x2)<minJoy){
				turning = 0;
			}
			// apportion motor capacity to movement and turning
			// TODO make this better... although that will be difficult
			totalAmount = 1 + turning + mag*3;
			movementAmount = (mag*3)/totalAmount;
			turningAmount = turning/totalAmount;
			// Apply finished values to motors
	  	motor[FL] = FLset*movementAmount+turning*turningAmount;
			motor[FR] = FRset*movementAmount-turning*turningAmount;
			motor[BL] = FRset*movementAmount+turning*turningAmount;
			motor[BR] = FLset*movementAmount-turning*turningAmount;
		} else {
			// Resets movement values
			LF = 0;RF = 0;LB = 0;RB = 0;
			// Get joystick values
			x1 = joystick.joy1_x1 * .5;y1 = joystick.joy1_y1 * .5;
			x2 = joystick.joy1_x2 * .5;y2 = joystick.joy1_y2 * .5;
			// Handle Strafing Movement
			LF += x1;RF -= x1;LB -= x1;RB += x1;
			// Handle Regular Movement
			LF += y1;RF += y1;LB += y1;RB += y1;
			// Handle Turning Movement
			LF += x2;RF -= x2;LB += x2;RB -= x2;
			if (abs(joystick.joy1_x1)<minJoy&&abs(joystick.joy1_y1)<minJoy&&abs(joystick.joy1_x2)<minJoy){
				LF = 0;RF = 0;LB = 0;RB = 0;
			}
			// Apply Finished values to motors.
			motor[FL] = LF;
			motor[FR] = RF;
			motor[BL] = LB;
			motor[BR] = RB;
		}
		wait10Msec(1);
	}
}

task drive(){
	float x1,y1,x2,y2,LF,RF,LB,RB= 0;
	int minJoy = 12;
	while(true){
		// Resets movement values
		LF = 0;RF = 0;LB = 0;RB = 0;
		// Get joystick values
		x1 = joystick.joy1_x1 * .5;y1 = joystick.joy1_y1 * .5;
		x2 = joystick.joy1_x2 * .5;y2 = joystick.joy1_y2 * .5;
		// Handle Strafing Movement
		LF += x1;RF -= x1;LB -= x1;RB += x1;
		//Handle Regular Movement
		LF += y1;RF += y1;LB += y1;RB += y1;
		//Handle Turning Movement
		LF += x2;RF -= x2;LB += x2;RB -= x2;
		if (abs(joystick.joy1_x1)<minJoy&&abs(joystick.joy1_y1)<minJoy&&abs(joystick.joy1_x2)<minJoy){
			LF = 0;RF = 0;LB = 0;RB = 0;
		}
		// Apply Finished values to motors.
		motor[FL] = LF;
		motor[FR] = RF;
		motor[BL] = LB;
		motor[BR] = RB;
		wait1Msec(10); // necessary if using task control to allow for other tasks to run
	}
}

task heading(){
	ClearTimer(T1); //sets timer to 0
	while(true){
		int currentReading = SensorValue[gyro] - initial; //gets the new sensor reading
		rotation += (currentReading) * (time1[T1] - lastTime) * .001; //modifies the header
		lastTime = time1[T1]; //sets the last time for the next reading
		if (time1[T1]>30000){ //this resets the timer after 30 seconds
			ClearTimer(T1);
			lastTime = 0;
		}
		radRotation = rotation/180*PI;
		wait10Msec(1); //lets other tasks run
	}
}

task display(){
	while (true){
		eraseDisplay();
		//nxtDisplayCenteredTextLine(0, "Color: %d", c);
		nxtDisplayCenteredTextLine(0, "Heading: %d", rotation);
		nxtDisplayCenteredTextLine(1, "joyAngle: %d", joyAngle);
		wait1Msec(20);
	}
}

task main(){
  initializeRobot();

  waitForStart();   // wait for start of tele-op phase
  StartTask(display);
	StartTask(heading);
  //StartTask(drive);
  StartTask(superDrive);
  while (true)
  {
	  wait10Msec(1000);
  }
}
